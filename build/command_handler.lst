ARM GAS  /var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"command_handler.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "Core/Src/command_handler/command_handler.c"
  20              		.section	.text.CommandHandler_Init,"ax",%progbits
  21              		.align	1
  22              		.global	CommandHandler_Init
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	CommandHandler_Init:
  28              	.LFB137:
   1:Core/Src/command_handler/command_handler.c **** /**
   2:Core/Src/command_handler/command_handler.c ****   ******************************************************************************
   3:Core/Src/command_handler/command_handler.c ****   * @file    command_handler.c
   4:Core/Src/command_handler/command_handler.c ****   * @brief   This file handles high-level command logic, timing for measurements,
   5:Core/Src/command_handler/command_handler.c ****   * and triggering data acquisition.
   6:Core/Src/command_handler/command_handler.c ****   ******************************************************************************
   7:Core/Src/command_handler/command_handler.c ****   */
   8:Core/Src/command_handler/command_handler.c **** 
   9:Core/Src/command_handler/command_handler.c **** /* Includes ------------------------------------------------------------------*/
  10:Core/Src/command_handler/command_handler.c **** #include "command_handler.h"
  11:Core/Src/command_handler/command_handler.c **** // Other includes like i2c_handler.h, timer.h, uart_handler.h are brought in via command_handler.h
  12:Core/Src/command_handler/command_handler.c **** 
  13:Core/Src/command_handler/command_handler.c **** /* Private define ------------------------------------------------------------*/
  14:Core/Src/command_handler/command_handler.c **** #define MEASUREMENT_INTERVAL_MS 1000 // Interval for triggering accelerometer reads
  15:Core/Src/command_handler/command_handler.c **** 
  16:Core/Src/command_handler/command_handler.c **** /* Private macro -------------------------------------------------------------*/
  17:Core/Src/command_handler/command_handler.c **** /* Private variables ---------------------------------------------------------*/
  18:Core/Src/command_handler/command_handler.c **** static u32 s_command_timer = 0;         ///< Timer for periodic command/measurement execution.
  19:Core/Src/command_handler/command_handler.c **** static bool s_i2c_module_ready = false; ///< Flag indicating if I2C peripheral and target device ar
  20:Core/Src/command_handler/command_handler.c **** 
  21:Core/Src/command_handler/command_handler.c **** // The global 'acc_enabled' (from i2c_handler.h) indicates if the LIS3DH has been successfully conf
  22:Core/Src/command_handler/command_handler.c **** // The global 'rawData' (from i2c_handler.h) is where LIS3DH data is stored by I2C_Read_ACC.
  23:Core/Src/command_handler/command_handler.c **** 
  24:Core/Src/command_handler/command_handler.c **** /* Private function prototypes -----------------------------------------------*/
  25:Core/Src/command_handler/command_handler.c **** // TODO: SD Card needs to be discussed -> Not available with the current setup
  26:Core/Src/command_handler/command_handler.c **** //* What would be better to log data to SD card or just UART?
  27:Core/Src/command_handler/command_handler.c **** 
  28:Core/Src/command_handler/command_handler.c **** // static void log_to_sd(u32 timestamp, int16_t acc_x, int16_t acc_y, int16_t acc_z) {
  29:Core/Src/command_handler/command_handler.c **** //     FIL file;
  30:Core/Src/command_handler/command_handler.c **** //     UINT bytes_written;
ARM GAS  /var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s 			page 2


  31:Core/Src/command_handler/command_handler.c **** //     char buffer[128]; // Increased buffer size for potentially longer strings
  32:Core/Src/command_handler/command_handler.c **** 
  33:Core/Src/command_handler/command_handler.c **** //     if (f_open(&file, "data.csv", FA_OPEN_APPEND | FA_WRITE) != FR_OK) {
  34:Core/Src/command_handler/command_handler.c **** //         WriteUART_Blocking("SD file open failed.\r\n"); // Assuming WriteUART_Blocking for criti
  35:Core/Src/command_handler/command_handler.c **** //         return;
  36:Core/Src/command_handler/command_handler.c **** //     }
  37:Core/Src/command_handler/command_handler.c **** 
  38:Core/Src/command_handler/command_handler.c **** //     // Example for logging processed 16-bit values
  39:Core/Src/command_handler/command_handler.c **** //     snprintf(buffer, sizeof(buffer), "%lu,%d,%d,%d\r\n", timestamp, acc_x, acc_y, acc_z);
  40:Core/Src/command_handler/command_handler.c **** //     if (f_write(&file, buffer, strlen(buffer), &bytes_written) != FR_OK || bytes_written == 0) {
  41:Core/Src/command_handler/command_handler.c **** //         WriteUART_Blocking("SD file write failed.\r\n");
  42:Core/Src/command_handler/command_handler.c **** //     }
  43:Core/Src/command_handler/command_handler.c **** 
  44:Core/Src/command_handler/command_handler.c **** //     f_close(&file);
  45:Core/Src/command_handler/command_handler.c **** // }
  46:Core/Src/command_handler/command_handler.c **** 
  47:Core/Src/command_handler/command_handler.c **** 
  48:Core/Src/command_handler/command_handler.c **** /* Exported functions --------------------------------------------------------*/
  49:Core/Src/command_handler/command_handler.c **** 
  50:Core/Src/command_handler/command_handler.c **** /**
  51:Core/Src/command_handler/command_handler.c ****  * @brief Initializes command handler specific components (e.g., timers).
  52:Core/Src/command_handler/command_handler.c ****  * @param None
  53:Core/Src/command_handler/command_handler.c ****  * @retval None
  54:Core/Src/command_handler/command_handler.c ****  */
  55:Core/Src/command_handler/command_handler.c **** void CommandHandler_Init(void) {
  29              		.loc 1 55 32 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33 0000 08B5     		push	{r3, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 3, -8
  37              		.cfi_offset 14, -4
  56:Core/Src/command_handler/command_handler.c ****     s_command_timer = HAL_GetTick();      // Initialize command timer
  38              		.loc 1 56 5 view .LVU1
  39              		.loc 1 56 23 is_stmt 0 view .LVU2
  40 0002 FFF7FEFF 		bl	HAL_GetTick
  41              	.LVL0:
  42              		.loc 1 56 21 discriminator 1 view .LVU3
  43 0006 014B     		ldr	r3, .L3
  44 0008 1860     		str	r0, [r3]
  57:Core/Src/command_handler/command_handler.c ****     // Any other command_handler specific initializations can go here.
  58:Core/Src/command_handler/command_handler.c **** }
  45              		.loc 1 58 1 view .LVU4
  46 000a 08BD     		pop	{r3, pc}
  47              	.L4:
  48              		.align	2
  49              	.L3:
  50 000c 00000000 		.word	s_command_timer
  51              		.cfi_endproc
  52              	.LFE137:
  54              		.section	.text.CommandHandler_SetI2CReady,"ax",%progbits
  55              		.align	1
  56              		.global	CommandHandler_SetI2CReady
  57              		.syntax unified
  58              		.thumb
ARM GAS  /var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s 			page 3


  59              		.thumb_func
  61              	CommandHandler_SetI2CReady:
  62              	.LVL1:
  63              	.LFB138:
  59:Core/Src/command_handler/command_handler.c **** 
  60:Core/Src/command_handler/command_handler.c **** /**
  61:Core/Src/command_handler/command_handler.c ****  * @brief Sets the status of I2C module readiness.
  62:Core/Src/command_handler/command_handler.c ****  * @note This should be called from main after BVAT_I2C_Init() has determined
  63:Core/Src/command_handler/command_handler.c ****  * the I2C system and target device status.
  64:Core/Src/command_handler/command_handler.c ****  * @param is_ready: true if the I2C peripheral and target device are initialized and ready, false o
  65:Core/Src/command_handler/command_handler.c ****  * @retval None
  66:Core/Src/command_handler/command_handler.c ****  */
  67:Core/Src/command_handler/command_handler.c **** void CommandHandler_SetI2CReady(bool is_ready) {
  64              		.loc 1 67 48 is_stmt 1 view -0
  65              		.cfi_startproc
  66              		@ args = 0, pretend = 0, frame = 0
  67              		@ frame_needed = 0, uses_anonymous_args = 0
  68              		@ link register save eliminated.
  68:Core/Src/command_handler/command_handler.c ****     s_i2c_module_ready = is_ready;
  69              		.loc 1 68 5 view .LVU6
  70              		.loc 1 68 24 is_stmt 0 view .LVU7
  71 0000 014B     		ldr	r3, .L6
  72 0002 1870     		strb	r0, [r3]
  69:Core/Src/command_handler/command_handler.c **** }
  73              		.loc 1 69 1 view .LVU8
  74 0004 7047     		bx	lr
  75              	.L7:
  76 0006 00BF     		.align	2
  77              	.L6:
  78 0008 00000000 		.word	s_i2c_module_ready
  79              		.cfi_endproc
  80              	.LFE138:
  82              		.section	.rodata.measure_loop.str1.4,"aMS",%progbits,1
  83              		.align	2
  84              	.LC0:
  85 0000 41636365 		.ascii	"Accelerometer not enabled, attempting to enable...\015"
  85      6C65726F 
  85      6D657465 
  85      72206E6F 
  85      7420656E 
  86 0033 0A00     		.ascii	"\012\000"
  87 0035 000000   		.align	2
  88              	.LC1:
  89 0038 4D656173 		.ascii	"Measurement interval: Accelerometer not yet enabled"
  89      7572656D 
  89      656E7420 
  89      696E7465 
  89      7276616C 
  90 006b 20627920 		.ascii	" by IT callback.\015\012\000"
  90      49542063 
  90      616C6C62 
  90      61636B2E 
  90      0D0A00
  91              		.section	.text.measure_loop,"ax",%progbits
  92              		.align	1
  93              		.global	measure_loop
  94              		.syntax unified
ARM GAS  /var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s 			page 4


  95              		.thumb
  96              		.thumb_func
  98              	measure_loop:
  99              	.LFB139:
  70:Core/Src/command_handler/command_handler.c **** 
  71:Core/Src/command_handler/command_handler.c **** /**
  72:Core/Src/command_handler/command_handler.c ****  * @brief Main measurement loop logic.
  73:Core/Src/command_handler/command_handler.c ****  * Checks I2C and accelerometer status, and periodically triggers an accelerometer data read.
  74:Core/Src/command_handler/command_handler.c ****  * Actual data processing and UART logging of accelerometer data is expected to occur
  75:Core/Src/command_handler/command_handler.c ****  * within I2C HAL callbacks (e.g., HAL_I2C_MemRxCpltCallback in i2c_handler.c).
  76:Core/Src/command_handler/command_handler.c ****  * @param None
  77:Core/Src/command_handler/command_handler.c ****  * @retval None
  78:Core/Src/command_handler/command_handler.c ****  */
  79:Core/Src/command_handler/command_handler.c **** void measure_loop(void) {
 100              		.loc 1 79 25 is_stmt 1 view -0
 101              		.cfi_startproc
 102              		@ args = 0, pretend = 0, frame = 0
 103              		@ frame_needed = 0, uses_anonymous_args = 0
 104 0000 08B5     		push	{r3, lr}
 105              	.LCFI1:
 106              		.cfi_def_cfa_offset 8
 107              		.cfi_offset 3, -8
 108              		.cfi_offset 14, -4
  80:Core/Src/command_handler/command_handler.c ****     if (!s_i2c_module_ready) {
 109              		.loc 1 80 5 view .LVU10
 110              		.loc 1 80 9 is_stmt 0 view .LVU11
 111 0002 144B     		ldr	r3, .L17
 112 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 113              		.loc 1 80 8 view .LVU12
 114 0006 B3B1     		cbz	r3, .L14
  81:Core/Src/command_handler/command_handler.c ****         // This message might be too frequent if I2C init failed.
  82:Core/Src/command_handler/command_handler.c ****         // Consider printing it once or less often from main loop.
  83:Core/Src/command_handler/command_handler.c ****         // WriteUART_Blocking("I2C system not ready, skipping measurement.\r\n");
  84:Core/Src/command_handler/command_handler.c ****         HAL_Delay(MEASUREMENT_INTERVAL_MS); // Still delay to keep a rhythm
  85:Core/Src/command_handler/command_handler.c ****         return;
  86:Core/Src/command_handler/command_handler.c ****     }
  87:Core/Src/command_handler/command_handler.c **** 
  88:Core/Src/command_handler/command_handler.c ****     // acc_enabled is a volatile bool externed from i2c_handler.h
  89:Core/Src/command_handler/command_handler.c ****     // It should be set to true in HAL_I2C_MemTxCpltCallback after I2C_ACC_Enable's IT write comple
  90:Core/Src/command_handler/command_handler.c ****     if (!acc_enabled) {
 115              		.loc 1 90 5 is_stmt 1 view .LVU13
 116              		.loc 1 90 9 is_stmt 0 view .LVU14
 117 0008 134B     		ldr	r3, .L17+4
 118 000a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 119              		.loc 1 90 8 view .LVU15
 120 000c C3B1     		cbz	r3, .L15
 121              	.L11:
  91:Core/Src/command_handler/command_handler.c ****         WriteUART_Blocking("Accelerometer not enabled, attempting to enable...\r\n");
  92:Core/Src/command_handler/command_handler.c ****         I2C_ACC_Enable(); // This function uses IT write, acc_enabled will be set in its callback.
  93:Core/Src/command_handler/command_handler.c ****                           // We might not read immediately after this call in the same loop iterati
  94:Core/Src/command_handler/command_handler.c ****     }
  95:Core/Src/command_handler/command_handler.c **** 
  96:Core/Src/command_handler/command_handler.c ****     // Check timer for periodic measurement trigger
  97:Core/Src/command_handler/command_handler.c ****     if (timer_handler(MEASUREMENT_INTERVAL_MS, &s_command_timer)) {
 122              		.loc 1 97 5 is_stmt 1 view .LVU16
 123              		.loc 1 97 9 is_stmt 0 view .LVU17
 124 000e 1349     		ldr	r1, .L17+8
ARM GAS  /var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s 			page 5


 125 0010 4FF47A70 		mov	r0, #1000
 126 0014 FFF7FEFF 		bl	timer_handler
 127              	.LVL2:
 128              		.loc 1 97 8 discriminator 1 view .LVU18
 129 0018 88B1     		cbz	r0, .L8
  98:Core/Src/command_handler/command_handler.c ****         if (s_i2c_module_ready && acc_enabled) {
 130              		.loc 1 98 9 is_stmt 1 view .LVU19
 131              		.loc 1 98 13 is_stmt 0 view .LVU20
 132 001a 0E4B     		ldr	r3, .L17
 133 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 134              		.loc 1 98 12 view .LVU21
 135 001e 13B1     		cbz	r3, .L12
 136              		.loc 1 98 32 discriminator 1 view .LVU22
 137 0020 0D4A     		ldr	r2, .L17+4
 138 0022 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 139 0024 92B9     		cbnz	r2, .L16
 140              	.L12:
  99:Core/Src/command_handler/command_handler.c ****             // WriteUART_Blocking("Triggering I2C Accelerometer Read (IT)...\r\n"); // Optional deb
 100:Core/Src/command_handler/command_handler.c ****             I2C_Read_ACC(); // Initiate an interrupt-driven read into global rawData.
 101:Core/Src/command_handler/command_handler.c ****                             // The result will be processed and printed in HAL_I2C_MemRxCpltCallbac
 102:Core/Src/command_handler/command_handler.c ****                             // (defined in i2c_handler.c).
 103:Core/Src/command_handler/command_handler.c ****         } else if (s_i2c_module_ready && !acc_enabled) {
 141              		.loc 1 103 16 is_stmt 1 view .LVU23
 142              		.loc 1 103 19 is_stmt 0 view .LVU24
 143 0026 53B1     		cbz	r3, .L8
 144              		.loc 1 103 42 discriminator 1 view .LVU25
 145 0028 0B4B     		ldr	r3, .L17+4
 146 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 147              		.loc 1 103 39 discriminator 1 view .LVU26
 148 002c 3BB9     		cbnz	r3, .L8
 104:Core/Src/command_handler/command_handler.c ****             WriteUART_Blocking("Measurement interval: Accelerometer not yet enabled by IT callback.
 149              		.loc 1 104 13 is_stmt 1 view .LVU27
 150 002e 0C48     		ldr	r0, .L17+12
 151 0030 FFF7FEFF 		bl	WriteUART_Blocking
 152              	.LVL3:
 153 0034 03E0     		b	.L8
 154              	.L14:
  84:Core/Src/command_handler/command_handler.c ****         return;
 155              		.loc 1 84 9 view .LVU28
 156 0036 4FF47A70 		mov	r0, #1000
 157 003a FFF7FEFF 		bl	HAL_Delay
 158              	.LVL4:
  85:Core/Src/command_handler/command_handler.c ****     }
 159              		.loc 1 85 9 view .LVU29
 160              	.L8:
 105:Core/Src/command_handler/command_handler.c ****         }
 106:Core/Src/command_handler/command_handler.c ****     }
 107:Core/Src/command_handler/command_handler.c **** }...
 161              		.loc 1 107 1 is_stmt 0 view .LVU30
 162 003e 08BD     		pop	{r3, pc}
 163              	.L15:
  91:Core/Src/command_handler/command_handler.c ****         WriteUART_Blocking("Accelerometer not enabled, attempting to enable...\r\n");
 164              		.loc 1 91 9 is_stmt 1 view .LVU31
 165 0040 0848     		ldr	r0, .L17+16
 166 0042 FFF7FEFF 		bl	WriteUART_Blocking
 167              	.LVL5:
  92:Core/Src/command_handler/command_handler.c ****         I2C_ACC_Enable(); // This function uses IT write, acc_enabled will be set in its callback.
ARM GAS  /var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s 			page 6


 168              		.loc 1 92 9 view .LVU32
 169 0046 FFF7FEFF 		bl	I2C_ACC_Enable
 170              	.LVL6:
 171 004a E0E7     		b	.L11
 172              	.L16:
 100:Core/Src/command_handler/command_handler.c ****             I2C_Read_ACC(); // Initiate an interrupt-driven read into global rawData.
 173              		.loc 1 100 13 view .LVU33
 174 004c FFF7FEFF 		bl	I2C_Read_ACC
 175              	.LVL7:
 176 0050 F5E7     		b	.L8
 177              	.L18:
 178 0052 00BF     		.align	2
 179              	.L17:
 180 0054 00000000 		.word	s_i2c_module_ready
 181 0058 00000000 		.word	acc_enabled
 182 005c 00000000 		.word	s_command_timer
 183 0060 38000000 		.word	.LC1
 184 0064 00000000 		.word	.LC0
 185              		.cfi_endproc
 186              	.LFE139:
 188              		.section	.bss.s_i2c_module_ready,"aw",%nobits
 191              	s_i2c_module_ready:
 192 0000 00       		.space	1
 193              		.section	.bss.s_command_timer,"aw",%nobits
 194              		.align	2
 197              	s_command_timer:
 198 0000 00000000 		.space	4
 199              		.text
 200              	.Letext0:
 201              		.file 2 "/Applications/ArmGNUToolchain/13.3.rel1/arm-none-eabi/arm-none-eabi/include/machine/_defa
 202              		.file 3 "/Applications/ArmGNUToolchain/13.3.rel1/arm-none-eabi/arm-none-eabi/include/sys/_stdint.h
 203              		.file 4 "Core/Src/i2c_handler/i2c_handler.h"
 204              		.file 5 "Core/Src/uart_handler/uart_handler.h"
 205              		.file 6 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal.h"
 206              		.file 7 "Core/Src/library/aml_hal.h"
 207              		.file 8 "Core/Src/timer/timer.h"
ARM GAS  /var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s 			page 7


DEFINED SYMBOLS
                            *ABS*:00000000 command_handler.c
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:21     .text.CommandHandler_Init:00000000 $t
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:27     .text.CommandHandler_Init:00000000 CommandHandler_Init
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:50     .text.CommandHandler_Init:0000000c $d
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:197    .bss.s_command_timer:00000000 s_command_timer
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:55     .text.CommandHandler_SetI2CReady:00000000 $t
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:61     .text.CommandHandler_SetI2CReady:00000000 CommandHandler_SetI2CReady
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:78     .text.CommandHandler_SetI2CReady:00000008 $d
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:191    .bss.s_i2c_module_ready:00000000 s_i2c_module_ready
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:83     .rodata.measure_loop.str1.4:00000000 $d
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:92     .text.measure_loop:00000000 $t
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:98     .text.measure_loop:00000000 measure_loop
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:180    .text.measure_loop:00000054 $d
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:192    .bss.s_i2c_module_ready:00000000 $d
/var/folders/25/vg8ydb454_z3v37m53jqj5280000gn/T//cclyHnDa.s:194    .bss.s_command_timer:00000000 $d

UNDEFINED SYMBOLS
HAL_GetTick
timer_handler
WriteUART_Blocking
HAL_Delay
I2C_ACC_Enable
I2C_Read_ACC
acc_enabled
